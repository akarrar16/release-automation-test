#!/bin/bash
set -e

git fetch --prune --prune-tags origin

response_body_file="response.json"

current_date=$(date '+%Y-%m-%d')
echo "Current date: ${current_date}"
tag_date=${current_date//-/.}
tag_date=v${tag_date:2}
echo "Current tag generated out of date: ${tag_date}"

# latest_tag=$(git describe --tags --match="v[0-9].[0-9].[0-9]*" $(git rev-list --tags --max-count=10) | head -n 1)
latest_tag=$(git describe --tags --match="v[0-9]*.[0-9]*.*" $(git rev-list --tags --max-count=10) 2>/dev/null | head -n 1)
echo "Found latest tag: ${latest_tag}"
latest_tag_commit_hash=$(git rev-list -n 1 ${latest_tag})
echo "latest_tag_commit_hash: $latest_tag_commit_hash"
head_commit_hash=$(git rev-parse HEAD)
echo "head_commit_hash: $head_commit_hash"
if [ "$latest_tag_commit_hash" = "$head_commit_hash" ]; then
echo "INFO: Tag $latest_tag is current head, no new tag will be created"
exit 0
fi
if [ $(git tag -l "$tag_date") ]; then
echo "ERROR: Tag $tag_date already exist!"
# exit 1
fi

if [ $(git tag -l "$tag_date") ]; then
    echo "Tag $tag_date already exists. calculating increment..."
    counter=1
    while true; do
        candidate_tag="${tag_date}.${counter}"
        if [ ! $(git tag -l "$candidate_tag") ]; then
            tag_date="$candidate_tag"
            break
        fi
        ((counter++))
    done
fi

echo "New tag will be: ${tag_date}"

echo "Creating new tag: ${tag_date}"
git tag ${tag_date}
echo "Pushing tag"
git push origin refs/tags/${tag_date}

echo "Generating Release Notes..."
echo "Gathering commit history..."
raw_commits=$(git log "${latest_tag}..HEAD" --pretty=format:"- %h %s (%an)")

echo "Gathering code changes..."
# We use 'git diff' to get the actual changes.
# We limit to 30k characters to prevent token overflow/shell crashes.
raw_diff=$(git diff "${latest_tag}..HEAD" | head -c 30000)

# Check if we truncated the diff
full_diff_size=$(git diff "${latest_tag}..HEAD" | wc -c)
if [ "$full_diff_size" -gt 30000 ]; then
    raw_diff="${raw_diff}\n\n...[DIFF TRUNCATED DUE TO SIZE LIMIT]..."
    echo "Notice: Diff is too large ($full_diff_size bytes). Sending first 30k bytes to AI."
fi

# --- STEP: CONSTRUCT PROMPT ---

# Create a temporary file for the prompt to avoid shell escaping issues
prompt_file=$(mktemp)

cat > "$prompt_file" <<EOF
You are a Technical Release Manager. I will provide you with the Commit Messages (Intent) and the Raw Code Diff (Reality) for a software release.

Your Goal: Write a clean, categorized Release Notes summary in Markdown.

Directives:
1. Analyze the 'Diff' to understand what actually changed. Use the 'Commits' for context on *why* it changed.
2. If a commit message is vague (e.g., "fix"), look at the diff to describe what was actually fixed.
3. Group items into: '## ðŸš€ Features', '## ðŸ› Bug Fixes', and '## ðŸ”§ Maintenance'.
4. Be concise. Do not include raw code blocks in the output.

---
INPUT DATA:

[COMMIT MESSAGES]
$raw_commits

[CODE DIFF]
$raw_diff
EOF

# --- STEP: EXECUTE AI ---

echo "Sending data to Gemini..."
ai_output_file=$(mktemp)

# Pass the prompt file to gemini cli
# We use 'cat' to pipe the file content into the cli
cat "$prompt_file" | gemini - > "$ai_output_file" 2>/dev/null
cli_exit_code=$?

if [ $cli_exit_code -eq 0 ] && [ -s "$ai_output_file" ]; then
    echo "AI Generation Successful."
    release_notes=$(cat "$ai_output_file")
    # Add a footer so users know it was AI-generated
    release_notes="${release_notes}\n\n_(Auto-generated by Gemini AI)_"
else
    echo "WARNING: AI Generation failed (Exit code $cli_exit_code) or returned empty. Falling back to raw commits."
    release_notes="## Changes\n$raw_commits"
fi

rm "$ai_output_file"

# Escape backslashes and double quotes for JSON compliance
release_notes="${release_notes//\\/\\\\}"
release_notes="${release_notes//\"/\\\"}"
# Escape newlines (replace literal newline with \n)
release_notes="${release_notes//$'\n'/\\n}"

echo "Contacting GitHub API..."

# Create the JSON payload
api_json=$(cat <<EOF
{
  "tag_name": "$tag_date",
  "target_commitish": "main",
  "name": "Release $tag_date",
  "body": "Automated Release.\\n\\nChanges:\\n$release_notes",
  "draft": false,
  "prerelease": false
}
EOF
)

# Send the Request
http_code=$(curl -s -X POST \
     -H "Authorization: Bearer $GITHUB_TOKEN" \
     -H "Accept: application/json" \
     -d "$api_json" \
     -w "%{http_code}" \
     -o "$response_body_file" \
     "https://api.github.com/repos/akarrar16/release-automation-test/releases")

echo "Release creation request sent."
echo "Checking if creation was successful ..."

# Check the response
if [ "$http_code" -eq 201 ]; then
    echo "SUCCESS: Release $tag_date created successfully!"
    echo "Release URL: $(grep -o '"html_url": "[^"]*' "$response_body_file" | cut -d'"' -f4)"
else
    echo "ERROR: Failed to create release. HTTP Status: $http_code"
    echo "Server Response:"
    cat "$response_body_file" || echo "No response body."
    # Clean up and exit with error
    rm "$response_body_file"
    exit 1
fi

# Cleanup
rm "$response_body_file"

echo ""
echo "Done."
